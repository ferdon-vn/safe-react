{"version":3,"sources":["logic/safe/transactions/gas.ts","logic/contracts/methodIds.ts","logic/safe/store/actions/createTransaction.ts","routes/safe/store/models/types/transactions.d.ts","logic/safe/safeTxSigner.ts","logic/safe/store/actions/transactions/pendingTransactions.ts","logic/safe/store/actions/utils.ts","test/utils/ethereumErrors.ts"],"names":["estimateDataGasCosts","data","match","reduce","accumulator","currentValue","EMPTY_DATA","estimateTxGasCosts","safeAddress","to","tx","preApprovingOwner","a","web3","getWeb3","getAccountFrom","from","safeInstance","eth","Contract","GnosisSafeSol","abi","methods","nonce","call","getThreshold","threshold","confirmations","size","Number","signatures","generateSignaturesFromTxConfirmations","replace","execTransaction","value","CALL","safeTxGas","ZERO_ADDRESS","encodeABI","txData","getTransactionHash","txHash","approveHash","calculateGasOf","gas","calculateGasPrice","gasPrice","parseInt","console","error","getDataFromNodeErrorMessage","errorMessage","split","errorAsJSON","JSON","parse","join","originalError","getGasEstimationTxResponse","txConfig","result","sameString","BigNumber","substring","toNumber","estimationData","message","Error","calculateMinimumGasForTransaction","additionalGasBatches","estimateData","txGasEstimation","dataGasEstimation","additionalGas","amountOfGasToTryTx","log","estimateSafeTxGas","safe","valueInWei","operation","getGnosisSafeInstanceAt","requiredTxGas","gasEstimationResponse","decodeMethods","length","slice","methodId","params","METHOD_TO_ID","isSafeMethod","decodedParameters","decodeParameters","method","parameters","name","type","decodeParamsFromSafeMethod","createTransaction","onUserConfirm","onError","notifiedTransaction","txNonce","navigateToTransactionsTab","origin","safeTxGasArg","dispatch","getState","state","push","SAFELIST_ADDRESS","onboardUser","providerSelector","account","hardwareWallet","smartContractWallet","getLastTx","lastTx","getNewTxNonce","toString","shouldExecuteTransaction","isExecution","getCurrentSafeVersion","safeVersion","sigs","notificationsQueue","getNotificationsFromTxType","beforeExecutionKey","enqueueSnackbar","beforeExecution","txArgs","baseGas","gasToken","refundReceiver","sender","safeTxHash","generateSafeTxHash","semverSatisfies","SAFE_VERSION_FOR_OFFCHAIN_SIGNATURES","tryOffchainSigning","signature","closeSnackbarAction","key","afterExecution","moreConfirmationsNeeded","fetchTransactions","saveTxToHistory","getExecutionTransaction","getApprovalTransaction","sendParams","txToMock","dataDecoded","submissionDate","Date","toISOString","mockTransaction","mockedTx","send","once","hash","pendingExecutionKey","pendingExecution","Promise","all","storeSignedTx","transaction","removeTxFromStore","on","then","receipt","noMoreConfirmationsNeeded","storeExecutedTx","transactionHash","errorMsg","afterExecutionError","executeDataUsedSignatures","getErrorMessage","options","address","errMsg","TxConstants","Operation","TransferMethods","SettingsChangeMethods","ConfirmationType","SignatureType","TokenType","TransferType","TxType","SAFE_METHODS_NAMES","ADD_OWNER_WITH_THRESHOLD","CHANGE_THRESHOLD","REMOVE_OWNER","SWAP_OWNER","ENABLE_MODULE","DISABLE_MODULE","confirmationsMap","map","obj","owner","toLowerCase","Object","keys","sort","forEach","addr","conf","setTxStatusAsPending","withMutations","updateIn","isCancellationTx","previous","set","TransactionStatus","PENDING","updateTxBasedOnReceipt","blockNumber","web3ReadOnly","utils","toWei","gasUsed","status","SUCCESS","FAILED","AWAITING_CONFIRMATIONS","findIndex","sameAddress","update","makeConfirmation","prev","clear","storeTx","AWAITING_YOUR_CONFIRMATION","cancelled","CANCELLED","safeTransactions","safeTransactionsSelector","transactions","txs","txIndex","batch","addOrUpdateCancellationTransactions","Map","addOrUpdateTransactions","List","rest","removeCancellationTransaction","removeTransaction","url","buildTxServiceUrl","axios","get","limit","response","results","isFirstTransaction","canExecuteCurrentTransaction","isExecuted","returnData","returnBuffer","Buffer","rawDecode"],"mappings":"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","file":"static/js/6.2615063e.chunk.js","sourcesContent":["import GnosisSafeSol from '@gnosis.pm/safe-contracts/build/contracts/GnosisSafe.json'\nimport { BigNumber } from 'bignumber.js'\nimport { AbiItem } from 'web3-utils'\n\nimport { CALL } from '.'\n\nimport { getGnosisSafeInstanceAt } from 'src/logic/contracts/safeContracts'\nimport { generateSignaturesFromTxConfirmations } from 'src/logic/safe/safeTxSigner'\nimport { Transaction } from 'src/logic/safe/store/models/types/transaction'\nimport { ZERO_ADDRESS } from 'src/logic/wallets/ethAddresses'\nimport { EMPTY_DATA, calculateGasOf, calculateGasPrice } from 'src/logic/wallets/ethTransactions'\nimport { getAccountFrom, getWeb3 } from 'src/logic/wallets/getWeb3'\nimport { GnosisSafe } from 'src/types/contracts/GnosisSafe.d'\nimport { sameString } from 'src/utils/strings'\n\nconst estimateDataGasCosts = (data: string): number => {\n  const reducer = (accumulator, currentValue) => {\n    if (currentValue === EMPTY_DATA) {\n      return accumulator + 0\n    }\n\n    if (currentValue === '00') {\n      return accumulator + 4\n    }\n\n    return accumulator + 16\n  }\n\n  return data.match(/.{2}/g)?.reduce(reducer, 0)\n}\n\nexport const estimateTxGasCosts = async (\n  safeAddress: string,\n  to: string,\n  data: string,\n  tx?: Transaction,\n  preApprovingOwner?: string,\n): Promise<number> => {\n  try {\n    const web3 = getWeb3()\n    const from = await getAccountFrom(web3)\n\n    if (!from) {\n      return 0\n    }\n\n    const safeInstance = (new web3.eth.Contract(GnosisSafeSol.abi as AbiItem[], safeAddress) as unknown) as GnosisSafe\n    const nonce = await safeInstance.methods.nonce().call()\n    const threshold = await safeInstance.methods.getThreshold().call()\n    const isExecution = tx?.confirmations.size === Number(threshold) || !!preApprovingOwner || threshold === '1'\n\n    let txData\n    if (isExecution) {\n      // https://docs.gnosis.io/safe/docs/docs5/#pre-validated-signatures\n      const signatures = tx?.confirmations\n        ? generateSignaturesFromTxConfirmations(tx.confirmations, preApprovingOwner)\n        : `0x000000000000000000000000${from.replace(\n            EMPTY_DATA,\n            '',\n          )}000000000000000000000000000000000000000000000000000000000000000001`\n      txData = await safeInstance.methods\n        .execTransaction(\n          to,\n          tx?.value || 0,\n          data,\n          CALL,\n          tx?.safeTxGas || 0,\n          0,\n          0,\n          ZERO_ADDRESS,\n          ZERO_ADDRESS,\n          signatures,\n        )\n        .encodeABI()\n    } else {\n      const txHash = await safeInstance.methods\n        .getTransactionHash(to, tx?.value || 0, data, CALL, 0, 0, 0, ZERO_ADDRESS, ZERO_ADDRESS, nonce)\n        .call({\n          from,\n        })\n      txData = await safeInstance.methods.approveHash(txHash).encodeABI()\n    }\n\n    const gas = await calculateGasOf(txData, from, safeAddress)\n    const gasPrice = await calculateGasPrice()\n\n    return gas * parseInt(gasPrice, 10)\n  } catch (err) {\n    console.error('Error while estimating transaction execution gas costs:')\n    console.error(err)\n\n    return 10000\n  }\n}\n\n// Parses the result from the error message (GETH, OpenEthereum/Parity and Nethermind) and returns the data value\nexport const getDataFromNodeErrorMessage = (errorMessage: string): string | undefined => {\n  // Extracts JSON object from the error message\n  const [, ...error] = errorMessage.split('\\n')\n  try {\n    const errorAsJSON = JSON.parse(error.join(''))\n\n    // For new GETH nodes they will return the data as error in the format:\n    // {\n    //   \"originalError\": {\n    //     \"code\": number,\n    //     \"data\": string,\n    //     \"message\": \"execution reverted: ...\"\n    //   }\n    // }\n    if (errorAsJSON.originalError && errorAsJSON.originalError.data) {\n      return errorAsJSON.originalError.data\n    }\n\n    // OpenEthereum/Parity nodes will return the data as error in the format:\n    // {\n    //     \"error\": {\n    //         \"code\": number,\n    //         \"message\": string,\n    //         \"data\": \"revert: 0x...\" -> this is the result data that should be extracted from the message\n    //      },\n    //     \"id\": number\n    // }\n    if (errorAsJSON?.data) {\n      const [, dataResult] = errorAsJSON.data.split(' ')\n      return dataResult\n    }\n  } catch (error) {\n    console.error(`Error trying to extract data from node error message: ${errorMessage}`)\n  }\n}\n\nconst getGasEstimationTxResponse = async (txConfig: {\n  to: string\n  from: string\n  data: string\n  gasPrice?: number\n  gas?: number\n}): Promise<number> => {\n  const web3 = getWeb3()\n  try {\n    const result = await web3.eth.call(txConfig)\n\n    // GETH Nodes (geth version < v1.9.24)\n    // In case that the gas is not enough we will receive an EMPTY data\n    // Otherwise we will receive the gas amount as hash data -> this is valid for old versions of GETH nodes ( < v1.9.24)\n\n    if (!sameString(result, EMPTY_DATA)) {\n      return new BigNumber(result.substring(138), 16).toNumber()\n    }\n  } catch (error) {\n    // So we try to extract the estimation result within the error in case is possible\n    const estimationData = getDataFromNodeErrorMessage(error.message)\n\n    if (!estimationData || sameString(estimationData, EMPTY_DATA)) {\n      throw error\n    }\n\n    return new BigNumber(estimationData.substring(138), 16).toNumber()\n  }\n\n  // This will fail in case that we receive an EMPTY_DATA on the GETH node gas estimation (for version < v1.9.24 of geth nodes)\n  // We cannot throw this error above because it will be captured again on the catch block bellow\n  throw new Error('Error while estimating the gas required for tx')\n}\n\nconst calculateMinimumGasForTransaction = async (\n  additionalGasBatches: number[],\n  safeAddress: string,\n  estimateData: string,\n  txGasEstimation: number,\n  dataGasEstimation: number,\n): Promise<number> => {\n  for (const additionalGas of additionalGasBatches) {\n    const amountOfGasToTryTx = txGasEstimation + dataGasEstimation + additionalGas\n    try {\n      await getGasEstimationTxResponse({\n        to: safeAddress,\n        from: safeAddress,\n        data: estimateData,\n        gasPrice: 0,\n        gas: amountOfGasToTryTx,\n      })\n      return txGasEstimation + additionalGas\n    } catch (error) {\n      console.log(`Error trying to estimate gas with amount: ${amountOfGasToTryTx}`)\n    }\n  }\n\n  return 0\n}\n\nexport const estimateSafeTxGas = async (\n  safe: GnosisSafe | undefined,\n  safeAddress: string,\n  data: string,\n  to: string,\n  valueInWei: string,\n  operation: number,\n): Promise<number> => {\n  try {\n    let safeInstance = safe\n    if (!safeInstance) {\n      safeInstance = await getGnosisSafeInstanceAt(safeAddress)\n    }\n\n    const estimateData = safeInstance.methods.requiredTxGas(to, valueInWei, data, operation).encodeABI()\n    const gasEstimationResponse = await getGasEstimationTxResponse({\n      to: safeAddress,\n      from: safeAddress,\n      data: estimateData,\n    })\n\n    const txGasEstimation = gasEstimationResponse + 10000\n\n    // 21000 - additional gas costs (e.g. base tx costs, transfer costs)\n    const dataGasEstimation = estimateDataGasCosts(estimateData) + 21000\n    const additionalGasBatches = [0, 10000, 20000, 40000, 80000, 160000, 320000, 640000, 1280000, 2560000, 5120000]\n\n    return await calculateMinimumGasForTransaction(\n      additionalGasBatches,\n      safeAddress,\n      estimateData,\n      txGasEstimation,\n      dataGasEstimation,\n    )\n  } catch (error) {\n    console.error('Error calculating tx gas estimation', error)\n    return 0\n  }\n}\n","import { web3ReadOnly as web3 } from 'src/logic/wallets/getWeb3'\nimport { DataDecoded, METHOD_TO_ID } from 'src/routes/safe/store/models/types/transactions.d'\n\nexport const decodeParamsFromSafeMethod = (data: string): DataDecoded | null => {\n  const [methodId, params] = [data.slice(0, 10) as keyof typeof METHOD_TO_ID | string, data.slice(10)]\n\n  switch (methodId) {\n    // swapOwner\n    case '0xe318b52b': {\n      const decodedParameters = web3.eth.abi.decodeParameters(['uint', 'address', 'address'], params) as string[]\n      return {\n        method: METHOD_TO_ID[methodId],\n        parameters: [\n          { name: 'oldOwner', type: 'address', value: decodedParameters[1] },\n          { name: 'newOwner', type: 'address', value: decodedParameters[2] },\n        ],\n      }\n    }\n\n    // addOwnerWithThreshold\n    case '0x0d582f13': {\n      const decodedParameters = web3.eth.abi.decodeParameters(['address', 'uint'], params)\n      return {\n        method: METHOD_TO_ID[methodId],\n        parameters: [\n          { name: 'owner', type: 'address', value: decodedParameters[0] },\n          { name: '_threshold', type: 'uint', value: decodedParameters[1] },\n        ],\n      }\n    }\n\n    // removeOwner\n    case '0xf8dc5dd9': {\n      const decodedParameters = web3.eth.abi.decodeParameters(['address', 'address', 'uint'], params)\n      return {\n        method: METHOD_TO_ID[methodId],\n        parameters: [\n          { name: 'owner', type: 'address', value: decodedParameters[1] },\n          { name: '_threshold', type: 'uint', value: decodedParameters[2] },\n        ],\n      }\n    }\n\n    // changeThreshold\n    case '0x694e80c3': {\n      const decodedParameters = web3.eth.abi.decodeParameters(['uint'], params)\n      return {\n        method: METHOD_TO_ID[methodId],\n        parameters: [\n          { name: '_threshold', type: 'uint', value: decodedParameters[0] },\n        ],\n      }\n    }\n\n    // enableModule\n    case '0x610b5925': {\n      const decodedParameters = web3.eth.abi.decodeParameters(['address'], params)\n      return {\n        method: METHOD_TO_ID[methodId],\n        parameters: [\n          { name: 'module', type: 'address', value: decodedParameters[0] },\n        ],\n      }\n    }\n\n    // disableModule\n    case '0xe009cfde': {\n      const decodedParameters = web3.eth.abi.decodeParameters(['address', 'address'], params)\n      return {\n        method: METHOD_TO_ID[methodId],\n        parameters: [\n          { name: 'prevModule', type: 'address', value: decodedParameters[0] },\n          { name: 'module', type: 'address', value: decodedParameters[1] },\n        ],\n      }\n    }\n\n    default:\n      return null\n  }\n}\n\nconst isSafeMethod = (methodId: string): boolean => {\n  return !!METHOD_TO_ID[methodId]\n}\n\nexport const decodeMethods = (data: string): DataDecoded | null => {\n  if(!data.length) {\n    return null\n  }\n\n  const [methodId, params] = [data.slice(0, 10), data.slice(10)]\n\n  if (isSafeMethod(methodId)) {\n    return decodeParamsFromSafeMethod(data)\n  }\n\n  switch (methodId) {\n    // a9059cbb - transfer(address,uint256)\n    case '0xa9059cbb': {\n      const decodeParameters = web3.eth.abi.decodeParameters(['address', 'uint'], params)\n      return {\n        method: 'transfer',\n        parameters: [\n          { name: 'to', type: '', value: decodeParameters[0] },\n          { name: 'value', type: '', value: decodeParameters[1] },\n        ],\n      }\n    }\n\n    // 23b872dd - transferFrom(address,address,uint256)\n    case '0x23b872dd': {\n      const decodeParameters = web3.eth.abi.decodeParameters(['address', 'address', 'uint'], params)\n      return {\n        method: 'transferFrom',\n        parameters: [\n          { name: 'from', type: '', value: decodeParameters[0] },\n          { name: 'to', type: '', value: decodeParameters[1] },\n          { name: 'value', type: '', value: decodeParameters[2] },\n        ],\n      }\n    }\n\n    // 42842e0e - safeTransferFrom(address,address,uint256)\n    case '0x42842e0e': {\n      const decodedParameters = web3.eth.abi.decodeParameters(['address', 'address', 'uint'], params)\n      return {\n        method: 'safeTransferFrom',\n        parameters: [\n          { name: 'from', type: '', value: decodedParameters[0] },\n          { name: 'to', type: '', value: decodedParameters[1] },\n          { name: 'value', type: '', value: decodedParameters[2] },\n        ],\n      }\n    }\n\n    default:\n      return null\n  }\n}\n","import { push } from 'connected-react-router'\nimport semverSatisfies from 'semver/functions/satisfies'\nimport { ThunkAction } from 'redux-thunk'\n\nimport { onboardUser } from 'src/components/ConnectButton'\nimport { decodeMethods } from 'src/logic/contracts/methodIds'\nimport { getGnosisSafeInstanceAt } from 'src/logic/contracts/safeContracts'\nimport { getNotificationsFromTxType } from 'src/logic/notifications'\nimport {\n  CALL,\n  getApprovalTransaction,\n  getExecutionTransaction,\n  SAFE_VERSION_FOR_OFFCHAIN_SIGNATURES,\n  saveTxToHistory,\n  tryOffchainSigning,\n} from 'src/logic/safe/transactions'\nimport { estimateSafeTxGas } from 'src/logic/safe/transactions/gas'\nimport { getCurrentSafeVersion } from 'src/logic/safe/utils/safeVersion'\nimport { ZERO_ADDRESS } from 'src/logic/wallets/ethAddresses'\nimport { EMPTY_DATA } from 'src/logic/wallets/ethTransactions'\nimport { providerSelector } from 'src/logic/wallets/store/selectors'\nimport { SAFELIST_ADDRESS } from 'src/routes/routes'\nimport enqueueSnackbar from 'src/logic/notifications/store/actions/enqueueSnackbar'\nimport closeSnackbarAction from 'src/logic/notifications/store/actions/closeSnackbar'\nimport {\n  removeTxFromStore,\n  storeSignedTx,\n  storeExecutedTx,\n} from 'src/logic/safe/store/actions/transactions/pendingTransactions'\nimport {\n  generateSafeTxHash,\n  mockTransaction,\n  TxToMock,\n} from 'src/logic/safe/store/actions/transactions/utils/transactionHelpers'\nimport { getLastTx, getNewTxNonce, shouldExecuteTransaction } from 'src/logic/safe/store/actions/utils'\nimport { getErrorMessage } from 'src/test/utils/ethereumErrors'\nimport fetchTransactions from './transactions/fetchTransactions'\nimport { TxArgs } from 'src/logic/safe/store/models/types/transaction'\nimport { AnyAction } from 'redux'\nimport { PayableTx } from 'src/types/contracts/types.d'\nimport { AppReduxState } from 'src/store'\nimport { Dispatch, DispatchReturn } from './types'\n\ninterface CreateTransactionArgs {\n  navigateToTransactionsTab?: boolean\n  notifiedTransaction: string\n  operation?: number\n  origin?: string | null\n  safeAddress: string\n  to: string\n  txData?: string\n  txNonce?: number | string\n  valueInWei: string\n  safeTxGas?: number\n}\n\ntype CreateTransactionAction = ThunkAction<Promise<void | string>, AppReduxState, DispatchReturn, AnyAction>\ntype ConfirmEventHandler = (safeTxHash: string) => void\ntype ErrorEventHandler = () => void\n\nconst createTransaction = (\n  {\n    safeAddress,\n    to,\n    valueInWei,\n    txData = EMPTY_DATA,\n    notifiedTransaction,\n    txNonce,\n    operation = CALL,\n    navigateToTransactionsTab = true,\n    origin = null,\n    safeTxGas: safeTxGasArg,\n  }: CreateTransactionArgs,\n  onUserConfirm?: ConfirmEventHandler,\n  onError?: ErrorEventHandler,\n): CreateTransactionAction => async (dispatch: Dispatch, getState: () => AppReduxState): Promise<DispatchReturn> => {\n  const state = getState()\n\n  if (navigateToTransactionsTab) {\n    dispatch(push(`${SAFELIST_ADDRESS}/${safeAddress}/transactions`))\n  }\n\n  const ready = await onboardUser()\n  if (!ready) return\n\n  const { account: from, hardwareWallet, smartContractWallet } = providerSelector(state)\n  const safeInstance = await getGnosisSafeInstanceAt(safeAddress)\n  const lastTx = await getLastTx(safeAddress)\n  const nonce = await getNewTxNonce(txNonce?.toString(), lastTx, safeInstance)\n  const isExecution = await shouldExecuteTransaction(safeInstance, nonce, lastTx)\n  const safeVersion = await getCurrentSafeVersion(safeInstance)\n  const safeTxGas =\n    safeTxGasArg || (await estimateSafeTxGas(safeInstance, safeAddress, txData, to, valueInWei, operation))\n\n  // https://docs.gnosis.io/safe/docs/docs5/#pre-validated-signatures\n  const sigs = `0x000000000000000000000000${from.replace(\n    '0x',\n    '',\n  )}000000000000000000000000000000000000000000000000000000000000000001`\n\n  const notificationsQueue = getNotificationsFromTxType(notifiedTransaction, origin)\n  const beforeExecutionKey = dispatch(enqueueSnackbar(notificationsQueue.beforeExecution))\n\n  let pendingExecutionKey\n\n  let txHash\n  const txArgs: TxArgs = {\n    safeInstance,\n    to,\n    valueInWei,\n    data: txData,\n    operation,\n    nonce: Number.parseInt(nonce),\n    safeTxGas,\n    baseGas: 0,\n    gasPrice: '0',\n    gasToken: ZERO_ADDRESS,\n    refundReceiver: ZERO_ADDRESS,\n    sender: from,\n    sigs,\n  }\n  const safeTxHash = generateSafeTxHash(safeAddress, txArgs)\n\n  try {\n    // Here we're checking that safe contract version is greater or equal 1.1.1, but\n    // theoretically EIP712 should also work for 1.0.0 contracts\n    const canTryOffchainSigning =\n      !isExecution && !smartContractWallet && semverSatisfies(safeVersion, SAFE_VERSION_FOR_OFFCHAIN_SIGNATURES)\n    if (canTryOffchainSigning) {\n      const signature = await tryOffchainSigning(safeTxHash, { ...txArgs, safeAddress }, hardwareWallet)\n\n      if (signature) {\n        dispatch(closeSnackbarAction({ key: beforeExecutionKey }))\n        dispatch(enqueueSnackbar(notificationsQueue.afterExecution.moreConfirmationsNeeded))\n        dispatch(fetchTransactions(safeAddress))\n\n        await saveTxToHistory({ ...txArgs, signature, origin })\n        onUserConfirm?.(safeTxHash)\n        return\n      }\n    }\n\n    const tx = isExecution\n      ? await getExecutionTransaction(txArgs)\n      : await getApprovalTransaction(safeInstance, safeTxHash)\n    const sendParams: PayableTx = { from, value: 0 }\n\n    // if not set owner management tests will fail on ganache\n    if (process.env.NODE_ENV === 'test') {\n      sendParams.gas = '7000000'\n    }\n\n    const txToMock: TxToMock = {\n      ...txArgs,\n      confirmations: [], // this is used to determine if a tx is pending or not. See `calculateTransactionStatus` helper\n      value: txArgs.valueInWei,\n      safeTxHash,\n      dataDecoded: decodeMethods(txArgs.data),\n      submissionDate: new Date().toISOString(),\n    }\n    const mockedTx = await mockTransaction(txToMock, safeAddress, state)\n\n    await tx\n      .send(sendParams)\n      .once('transactionHash', async (hash) => {\n        onUserConfirm?.(safeTxHash)\n        try {\n          txHash = hash\n          dispatch(closeSnackbarAction({ key: beforeExecutionKey }))\n\n          pendingExecutionKey = dispatch(enqueueSnackbar(notificationsQueue.pendingExecution))\n\n          await Promise.all([\n            saveTxToHistory({ ...txArgs, txHash, origin }),\n            storeSignedTx({ transaction: mockedTx, from, isExecution, safeAddress, dispatch, state }),\n          ])\n          dispatch(fetchTransactions(safeAddress))\n        } catch (e) {\n          removeTxFromStore(mockedTx, safeAddress, dispatch, state)\n        }\n      })\n      .on('error', (error) => {\n        dispatch(closeSnackbarAction({ key: pendingExecutionKey }))\n        removeTxFromStore(mockedTx, safeAddress, dispatch, state)\n        console.error('Tx error: ', error)\n\n        onError?.()\n      })\n      .then(async (receipt) => {\n        if (pendingExecutionKey) {\n          dispatch(closeSnackbarAction({ key: pendingExecutionKey }))\n        }\n\n        dispatch(\n          enqueueSnackbar(\n            isExecution\n              ? notificationsQueue.afterExecution.noMoreConfirmationsNeeded\n              : notificationsQueue.afterExecution.moreConfirmationsNeeded,\n          ),\n        )\n\n        await storeExecutedTx({ transaction: mockedTx, from, safeAddress, isExecution, receipt, dispatch, state })\n\n        dispatch(fetchTransactions(safeAddress))\n\n        return receipt.transactionHash\n      })\n  } catch (err) {\n    const errorMsg = err.message\n      ? `${notificationsQueue.afterExecutionError.message} - ${err.message}`\n      : notificationsQueue.afterExecutionError.message\n\n    console.error(`Error creating the TX: `, err)\n    dispatch(closeSnackbarAction({ key: beforeExecutionKey }))\n\n    if (pendingExecutionKey) {\n      dispatch(closeSnackbarAction({ key: pendingExecutionKey }))\n    }\n\n    dispatch(enqueueSnackbar(errorMsg))\n\n    const executeDataUsedSignatures = safeInstance.methods\n      .execTransaction(to, valueInWei, txData, operation, 0, 0, 0, ZERO_ADDRESS, ZERO_ADDRESS, sigs)\n      .encodeABI()\n    const errMsg = await getErrorMessage(safeInstance.options.address, 0, executeDataUsedSignatures, from)\n    console.error(`Error creating the TX - an attempt to get the error message: ${errMsg}`)\n  }\n\n  return txHash\n}\n\nexport default createTransaction\n","// TODO this file is duplicated with src/logic/safe/store/model/types/transaction.d.ts, we should remove it\nexport enum TxConstants {\n  MULTI_SEND = 'multiSend',\n  UNKNOWN = 'UNKNOWN',\n}\n\nexport enum Operation {\n  CALL,\n  DELEGATE_CALL,\n  CREATE,\n}\n\n// types comes from: https://github.com/gnosis/safe-client-gateway/blob/752e76b6d1d475791dbd7917b174bb41d2d9d8be/src/utils.rs\nexport enum TransferMethods {\n  TRANSFER = 'transfer',\n  TRANSFER_FROM = 'transferFrom',\n  SAFE_TRANSFER_FROM = 'safeTransferFrom',\n}\n\nexport enum SettingsChangeMethods {\n  SETUP = 'setup',\n  SET_FALLBACK_HANDLER = 'setFallbackHandler',\n  ADD_OWNER_WITH_THRESHOLD = 'addOwnerWithThreshold',\n  REMOVE_OWNER = 'removeOwner',\n  REMOVE_OWNER_WITH_THRESHOLD = 'removeOwnerWithThreshold',\n  SWAP_OWNER = 'swapOwner',\n  CHANGE_THRESHOLD = 'changeThreshold',\n  CHANGE_MASTER_COPY = 'changeMasterCopy',\n  ENABLE_MODULE = 'enableModule',\n  DISABLE_MODULE = 'disableModule',\n  EXEC_TRANSACTION_FROM_MODULE = 'execTransactionFromModule',\n  APPROVE_HASH = 'approveHash',\n  EXEC_TRANSACTION = 'execTransaction',\n}\n\n// note: this extends SAFE_METHODS_NAMES in /logic/contracts/methodIds.ts, we need to figure out which one we are going to use\nexport type DataDecodedMethod = TransferMethods | SettingsChangeMethods | string\n\nexport interface ValueDecoded {\n  operation: Operation\n  to: string\n  value: number\n  data: string\n  dataDecoded: DataDecoded\n}\n\nexport interface SingleTransactionMethodParameter {\n  name: string\n  type: string\n  value: string\n}\n\nexport interface MultiSendMethodParameter extends SingleTransactionMethodParameter {\n  valueDecoded: ValueDecoded[]\n}\n\nexport type Parameter = MultiSendMethodParameter | SingleTransactionMethodParameter\n\nexport interface DataDecoded {\n  method: DataDecodedMethod\n  parameters: Parameter[]\n}\n\nexport enum ConfirmationType {\n  CONFIRMATION = 'CONFIRMATION',\n  EXECUTION = 'EXECUTION',\n}\n\nexport enum SignatureType {\n  CONTRACT_SIGNATURE = 'CONTRACT_SIGNATURE',\n  APPROVED_HASH = 'APPROVED_HASH',\n  EOA = 'EOA',\n  ETH_SIGN = 'ETH_SIGN',\n}\n\nexport interface Confirmation {\n  owner: string\n  submissionDate: string\n  transactionHash: string | null\n  confirmationType: ConfirmationType\n  signature: string\n  signatureType: SignatureType\n}\n\nexport enum TokenType {\n  ERC20 = 'ERC20',\n  ERC721 = 'ERC721',\n  OTHER = 'OTHER',\n}\n\nexport interface TokenInfo {\n  type: TokenType\n  address: string\n  name: string\n  symbol: string\n  decimals: number\n  logoUri: string\n}\n\nexport enum TransferType {\n  ETHER_TRANSFER = 'ETHER_TRANSFER',\n  ERC20_TRANSFER = 'ERC20_TRANSFER',\n  ERC721_TRANSFER = 'ERC721_TRANSFER',\n  UNKNOWN = 'UNKNOWN',\n}\n\nexport interface Transfer {\n  type: TransferType\n  executionDate: string\n  blockNumber: number\n  transactionHash: string | null\n  to: string\n  value: string | null\n  tokenId: string | null\n  tokenAddress: string\n  tokenInfo: TokenInfo | null\n  from: string\n}\n\nexport enum TxType {\n  MULTISIG_TRANSACTION = 'MULTISIG_TRANSACTION',\n  ETHEREUM_TRANSACTION = 'ETHEREUM_TRANSACTION',\n  MODULE_TRANSACTION = 'MODULE_TRANSACTION',\n}\n\nexport interface MultiSigTransaction {\n  safe: string\n  to: string\n  value: string\n  data: string | null\n  operation: number\n  gasToken: string\n  safeTxGas: number\n  baseGas: number\n  gasPrice: string\n  refundReceiver: string\n  nonce: number\n  executionDate: string | null\n  submissionDate: string\n  modified: string\n  blockNumber: number | null\n  transactionHash: string | null\n  safeTxHash: string\n  executor: string | null\n  isExecuted: boolean\n  isSuccessful: boolean | null\n  ethGasPrice: string | null\n  gasUsed: number | null\n  fee: string | null\n  origin: string | null\n  dataDecoded: DataDecoded | null\n  confirmationsRequired: number | null\n  confirmations: Confirmation[]\n  signatures: string | null\n  transfers: Transfer[]\n  txType: TxType.MULTISIG_TRANSACTION\n}\n\nexport interface ModuleTransaction {\n  created: string\n  executionDate: string\n  blockNumber: number\n  transactionHash: string\n  safe: string\n  module: string\n  to: string\n  value: string\n  data: string\n  operation: Operation\n  transfers: Transfer[]\n  txType: TxType.MODULE_TRANSACTION\n}\n\nexport interface EthereumTransaction {\n  executionDate: string\n  to: string\n  data: string | null\n  txHash: string\n  blockNumber: number\n  transfers: Transfer[]\n  txType: TxType.ETHEREUM_TRANSACTION\n  from: string\n}\n\nexport type Transaction = MultiSigTransaction | ModuleTransaction | EthereumTransaction\n\n// SAFE METHODS TO ITS ID\n// https://github.com/gnosis/safe-contracts/blob/development/test/safeMethodNaming.js\n// https://github.com/gnosis/safe-contracts/blob/development/contracts/GnosisSafe.sol\n//  [\n//   { name: \"addOwnerWithThreshold\", id: \"0x0d582f13\" },\n//   { name: \"DOMAIN_SEPARATOR_TYPEHASH\", id: \"0x1db61b54\" },\n//   { name: \"isOwner\", id: \"0x2f54bf6e\" },\n//   { name: \"execTransactionFromModule\", id: \"0x468721a7\" },\n//   { name: \"signedMessages\", id: \"0x5ae6bd37\" },\n//   { name: \"enableModule\", id: \"0x610b5925\" },\n//   { name: \"changeThreshold\", id: \"0x694e80c3\" },\n//   { name: \"approvedHashes\", id: \"0x7d832974\" },\n//   { name: \"changeMasterCopy\", id: \"0x7de7edef\" },\n//   { name: \"SENTINEL_MODULES\", id: \"0x85e332cd\" },\n//   { name: \"SENTINEL_OWNERS\", id: \"0x8cff6355\" },\n//   { name: \"getOwners\", id: \"0xa0e67e2b\" },\n//   { name: \"NAME\", id: \"0xa3f4df7e\" },\n//   { name: \"nonce\", id: \"0xaffed0e0\" },\n//   { name: \"getModules\", id: \"0xb2494df3\" },\n//   { name: \"SAFE_MSG_TYPEHASH\", id: \"0xc0856ffc\" },\n//   { name: \"SAFE_TX_TYPEHASH\", id: \"0xccafc387\" },\n//   { name: \"disableModule\", id: \"0xe009cfde\" },\n//   { name: \"swapOwner\", id: \"0xe318b52b\" },\n//   { name: \"getThreshold\", id: \"0xe75235b8\" },\n//   { name: \"domainSeparator\", id: \"0xf698da25\" },\n//   { name: \"removeOwner\", id: \"0xf8dc5dd9\" },\n//   { name: \"VERSION\", id: \"0xffa1ad74\" },\n//   { name: \"setup\", id: \"0xa97ab18a\" },\n//   { name: \"execTransaction\", id: \"0x6a761202\" },\n//   { name: \"requiredTxGas\", id: \"0xc4ca3a9c\" },\n//   { name: \"approveHash\", id: \"0xd4d9bdcd\" },\n//   { name: \"signMessage\", id: \"0x85a5affe\" },\n//   { name: \"isValidSignature\", id: \"0x20c13b0b\" },\n//   { name: \"getMessageHash\", id: \"0x0a1028c4\" },\n//   { name: \"encodeTransactionData\", id: \"0xe86637db\" },\n//   { name: \"getTransactionHash\", id: \"0xd8d11f78\" }\n// ]\n\nexport const SAFE_METHODS_NAMES = {\n  ADD_OWNER_WITH_THRESHOLD: 'addOwnerWithThreshold',\n  CHANGE_THRESHOLD: 'changeThreshold',\n  REMOVE_OWNER: 'removeOwner',\n  SWAP_OWNER: 'swapOwner',\n  ENABLE_MODULE: 'enableModule',\n  DISABLE_MODULE: 'disableModule',\n}\n\nexport const METHOD_TO_ID = {\n  '0xe318b52b': SAFE_METHODS_NAMES.SWAP_OWNER,\n  '0x0d582f13': SAFE_METHODS_NAMES.ADD_OWNER_WITH_THRESHOLD,\n  '0xf8dc5dd9': SAFE_METHODS_NAMES.REMOVE_OWNER,\n  '0x694e80c3': SAFE_METHODS_NAMES.CHANGE_THRESHOLD,\n  '0x610b5925': SAFE_METHODS_NAMES.ENABLE_MODULE,\n  '0xe009cfde': SAFE_METHODS_NAMES.DISABLE_MODULE,\n}\n\nexport type SafeMethods = typeof SAFE_METHODS_NAMES[keyof typeof SAFE_METHODS_NAMES]\n\ntype TokenMethods = 'transfer' | 'transferFrom' | 'safeTransferFrom'\n\ntype SafeDecodedParams = {\n  [key in SafeMethods]?: Record<string, string>\n}\n\ntype TokenDecodedParams = {\n  [key in TokenMethods]?: Record<string, string>\n}\n\nexport type DecodedParams = SafeDecodedParams | TokenDecodedParams | null\n","// https://docs.gnosis.io/safe/docs/docs5/#pre-validated-signatures\n// https://github.com/gnosis/safe-contracts/blob/master/test/gnosisSafeTeamEdition.js#L26\nexport const generateSignaturesFromTxConfirmations = (confirmations, preApprovingOwner) => {\n  // The constant parts need to be sorted so that the recovered signers are sorted ascending\n  // (natural order) by address (not checksummed).\n  const confirmationsMap = confirmations.reduce((map, obj) => {\n    map[obj.owner.toLowerCase()] = obj // eslint-disable-line no-param-reassign\n    return map\n  }, {})\n\n  if (preApprovingOwner) {\n    confirmationsMap[preApprovingOwner.toLowerCase()] = { owner: preApprovingOwner }\n  }\n\n  let sigs = '0x'\n  Object.keys(confirmationsMap)\n    .sort()\n    .forEach((addr) => {\n      const conf = confirmationsMap[addr]\n      if (conf.signature) {\n        sigs += conf.signature.slice(2)\n      } else {\n        // https://docs.gnosis.io/safe/docs/docs5/#pre-validated-signatures\n        sigs += `000000000000000000000000${addr.replace(\n          '0x',\n          '',\n        )}000000000000000000000000000000000000000000000000000000000000000001`\n      }\n    })\n  return sigs\n}\n","import { List, Map } from 'immutable'\nimport { batch } from 'react-redux'\nimport { TransactionReceipt } from 'web3-core'\n\nimport { addOrUpdateCancellationTransactions } from 'src/logic/safe/store/actions/transactions/addOrUpdateCancellationTransactions'\nimport { addOrUpdateTransactions } from 'src/logic/safe/store/actions/transactions/addOrUpdateTransactions'\nimport { removeCancellationTransaction } from 'src/logic/safe/store/actions/transactions/removeCancellationTransaction'\nimport { removeTransaction } from 'src/logic/safe/store/actions/transactions/removeTransaction'\nimport { Dispatch } from 'src/logic/safe/store/actions/types.d'\nimport { makeConfirmation } from 'src/logic/safe/store/models/confirmation'\nimport { Transaction, TransactionStatus } from 'src/logic/safe/store/models/types/transaction'\nimport { safeTransactionsSelector } from 'src/logic/safe/store/selectors'\nimport { sameAddress } from 'src/logic/wallets/ethAddresses'\nimport { web3ReadOnly } from 'src/logic/wallets/getWeb3'\nimport { AppReduxState } from 'src/store'\n\ntype SetPendingTransactionParams = {\n  transaction: Transaction\n  from: string\n}\n\nconst setTxStatusAsPending = ({ transaction, from }: SetPendingTransactionParams): Transaction =>\n  transaction.withMutations((transaction) => {\n    transaction\n      // setting user as the one who has triggered the tx\n      // this allows to display the owner's \"pending\" status\n      .updateIn(['ownersWithPendingActions', transaction.isCancellationTx ? 'reject' : 'confirm'], (previous) =>\n        previous.push(from),\n      )\n      // global transaction status\n      .set('status', TransactionStatus.PENDING)\n  })\n\ntype SetOptimisticTransactionParams = {\n  transaction: Transaction\n  from: string\n  isExecution: boolean\n  receipt: TransactionReceipt\n}\n\nconst updateTxBasedOnReceipt = ({\n  transaction,\n  from,\n  isExecution,\n  receipt,\n}: SetOptimisticTransactionParams): Transaction => {\n  const txToStore = isExecution\n    ? transaction.withMutations((tx) => {\n        tx.set('executionTxHash', receipt.transactionHash)\n          .set('blockNumber', receipt.blockNumber)\n          .set('executionDate', tx.submissionDate)\n          .set('fee', web3ReadOnly.utils.toWei(`${receipt.gasUsed}`, 'gwei'))\n          .set('executor', from)\n          .set('isExecuted', true)\n          .set('isSuccessful', receipt.status)\n          .set('status', receipt.status ? TransactionStatus.SUCCESS : TransactionStatus.FAILED)\n      })\n    : transaction.set('status', TransactionStatus.AWAITING_CONFIRMATIONS)\n\n  return txToStore.withMutations((tx) => {\n    const senderHasAlreadyConfirmed = tx.confirmations.findIndex(({ owner }) => sameAddress(owner, from)) !== -1\n\n    if (!senderHasAlreadyConfirmed) {\n      // updates confirmations status\n      tx.update('confirmations', (confirmations) => confirmations.push(makeConfirmation({ owner: from })))\n    }\n\n    tx.updateIn(['ownersWithPendingActions', 'reject'], (prev) => prev.clear()).updateIn(\n      ['ownersWithPendingActions', 'confirm'],\n      (prev) => prev.clear(),\n    )\n  })\n}\n\ntype StoreTxParams = {\n  transaction: Transaction\n  safeAddress: string\n  dispatch: Dispatch\n  state: AppReduxState\n}\n\nexport const storeTx = async ({ transaction, safeAddress, dispatch, state }: StoreTxParams): Promise<void> => {\n  if (transaction.isCancellationTx) {\n    // `transaction` is the Cancellation tx\n    // So we need to decide the `status` for the main transaction this `transaction` is cancelling\n    let status: TransactionStatus = TransactionStatus.AWAITING_YOUR_CONFIRMATION\n    // `cancelled`, will become true if its corresponding Cancellation tx was successfully executed\n    let cancelled = false\n\n    switch (transaction.status) {\n      case TransactionStatus.SUCCESS:\n        status = TransactionStatus.CANCELLED\n        cancelled = true\n        break\n      case TransactionStatus.PENDING:\n        status = TransactionStatus.PENDING\n        break\n      default:\n        break\n    }\n\n    const safeTransactions = safeTransactionsSelector(state)\n\n    const transactions = safeTransactions.withMutations((txs) => {\n      const txIndex = txs.findIndex(({ nonce }) => Number(nonce) === Number(transaction.nonce))\n      txs.update(txIndex, (tx) => tx.set('status', status).set('cancelled', cancelled))\n    })\n\n    batch(() => {\n      dispatch(\n        addOrUpdateCancellationTransactions({\n          safeAddress,\n          transactions: Map({ [`${transaction.nonce}`]: transaction }),\n        }),\n      )\n      dispatch(addOrUpdateTransactions({ safeAddress, transactions }))\n    })\n  } else {\n    dispatch(addOrUpdateTransactions({ safeAddress, transactions: List([transaction]) }))\n  }\n}\n\ntype StoreSignedTxParams = StoreTxParams & {\n  from: string\n  isExecution: boolean\n}\n\nexport const storeSignedTx = ({ transaction, from, isExecution, ...rest }: StoreSignedTxParams): Promise<void> =>\n  storeTx({\n    transaction: isExecution ? setTxStatusAsPending({ transaction, from }) : transaction,\n    ...rest,\n  })\n\ntype StoreExecParams = StoreTxParams & {\n  from: string\n  isExecution: boolean\n  safeAddress: string\n  receipt: TransactionReceipt\n}\n\nexport const storeExecutedTx = ({ safeAddress, dispatch, state, ...rest }: StoreExecParams): Promise<void> =>\n  storeTx({\n    transaction: updateTxBasedOnReceipt({ ...rest }),\n    safeAddress,\n    dispatch,\n    state,\n  })\n\nexport const removeTxFromStore = (\n  transaction: Transaction,\n  safeAddress: string,\n  dispatch: Dispatch,\n  state: AppReduxState,\n): void => {\n  if (transaction.isCancellationTx) {\n    const safeTransactions = safeTransactionsSelector(state)\n    const transactions = safeTransactions.withMutations((txs) => {\n      const txIndex = txs.findIndex(({ nonce }) => Number(nonce) === Number(transaction.nonce))\n      txs[txIndex].set('status', TransactionStatus.AWAITING_YOUR_CONFIRMATION)\n    })\n\n    batch(() => {\n      dispatch(addOrUpdateTransactions({ safeAddress, transactions }))\n      dispatch(removeCancellationTransaction({ safeAddress, transaction }))\n    })\n  } else {\n    dispatch(removeTransaction({ safeAddress, transaction }))\n  }\n}\n","import { GnosisSafe } from 'src/types/contracts/GnosisSafe.d'\nimport { TxServiceModel } from './transactions/fetchTransactions/loadOutgoingTransactions'\nimport axios from 'axios'\n\nimport { buildTxServiceUrl } from 'src/logic/safe/transactions/txHistory'\n\nexport const getLastTx = async (safeAddress: string): Promise<TxServiceModel | null> => {\n  try {\n    const url = buildTxServiceUrl(safeAddress)\n    const response = await axios.get(url, { params: { limit: 1 } })\n\n    return response.data.results[0] || null\n  } catch (e) {\n    console.error('failed to retrieve last Tx from server', e)\n    return null\n  }\n}\n\nexport const getNewTxNonce = async (\n  txNonce: string | undefined,\n  lastTx: TxServiceModel | null,\n  safeInstance: GnosisSafe,\n): Promise<string> => {\n  if (txNonce) {\n    return txNonce\n  }\n\n  // use current's safe nonce as fallback\n  return lastTx ? `${lastTx.nonce + 1}` : (await safeInstance.methods.nonce().call()).toString()\n}\n\nexport const shouldExecuteTransaction = async (\n  safeInstance: GnosisSafe,\n  nonce: string,\n  lastTx: TxServiceModel | null,\n): Promise<boolean> => {\n  const threshold = await safeInstance.methods.getThreshold().call()\n\n  // Tx will automatically be executed if and only if the threshold is 1\n  if (Number.parseInt(threshold) === 1) {\n    const isFirstTransaction = Number.parseInt(nonce) === 0\n    // if the previous tx is not executed, it's delayed using the approval mechanisms,\n    // once the previous tx is executed, the current tx will be available to be executed\n    // by the user using the exec button.\n    const canExecuteCurrentTransaction = lastTx && lastTx.isExecuted\n\n    return isFirstTransaction || !!canExecuteCurrentTransaction\n  }\n\n  return false\n}\n","// \nimport abi from 'ethereumjs-abi'\nimport { getWeb3 } from 'src/logic/wallets/getWeb3'\n\nexport const getErrorMessage = async (to, value, data, from) => {\n  const web3 = getWeb3()\n  const returnData: any = await web3.eth.call({\n    to,\n    from,\n    value,\n    data,\n  })\n  const returnBuffer = Buffer.from(returnData.slice(2), 'hex')\n\n  return abi.rawDecode(['string'], returnBuffer.slice(4))[0]\n}\n"],"sourceRoot":""}